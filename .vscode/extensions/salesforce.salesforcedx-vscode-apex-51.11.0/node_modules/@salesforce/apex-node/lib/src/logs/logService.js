"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const i18n_1 = require("../i18n");
const path = require("path");
const MAX_NUM_LOGS = 25;
class LogService {
    constructor(connection) {
        this.connection = connection;
    }
    getLogIds(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(typeof options.logId === 'string' ||
                typeof options.numberOfLogs === 'number')) {
                throw new Error(i18n_1.nls.localize('missingInfoLogError'));
            }
            if (typeof options.numberOfLogs === 'number') {
                const logIdRecordList = yield this.getLogRecords(options.numberOfLogs);
                return logIdRecordList.map(logRecord => logRecord.Id);
            }
            return [options.logId];
        });
    }
    // TODO: readableStream cannot be used until updates are made in jsforce and sfdx-core
    getLogs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const logIdList = yield this.getLogIds(options);
            const logPaths = [];
            const connectionRequests = logIdList.map((id) => __awaiter(this, void 0, void 0, function* () {
                const url = `${this.connection.tooling._baseUrl()}/sobjects/ApexLog/${id}/Body`;
                const logRecord = yield this.toolingRequest(url);
                if (options.outputDir) {
                    const logPath = path.join(options.outputDir, `${id}.log`);
                    logPaths.push(logPath);
                    utils_1.createFile(logPath, logRecord);
                }
                return String(logRecord);
            }));
            const logs = yield Promise.all(connectionRequests);
            if (logPaths.length > 0) {
                const logMap = [];
                for (let i = 0; i < logs.length; i++) {
                    logMap.push({ log: logs[i], logPath: logPaths[i] });
                }
                return logMap;
            }
            return logs.map(log => {
                return { log };
            });
        });
    }
    getLogRecords(numberOfLogs) {
        return __awaiter(this, void 0, void 0, function* () {
            let query = 'Select Id, Application, DurationMilliseconds, Location, ';
            query +=
                'LogLength, LogUser.Name, Operation, Request, StartTime, Status from ApexLog Order By StartTime DESC';
            if (typeof numberOfLogs === 'number') {
                if (numberOfLogs <= 0) {
                    throw new Error(i18n_1.nls.localize('numLogsError'));
                }
                numberOfLogs = Math.min(numberOfLogs, MAX_NUM_LOGS);
                query += ` LIMIT ${numberOfLogs}`;
            }
            const response = (yield this.connection.tooling.query(query));
            return response.records;
        });
    }
    toolingRequest(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = (yield this.connection.tooling.request(url));
            return log;
        });
    }
}
exports.LogService = LogService;
//# sourceMappingURL=logService.js.map