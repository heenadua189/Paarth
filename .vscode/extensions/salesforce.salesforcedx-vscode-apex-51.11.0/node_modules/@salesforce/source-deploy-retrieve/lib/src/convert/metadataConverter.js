"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_registry_1 = require("../metadata-registry");
const fs_1 = require("fs");
const path_1 = require("path");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
const streams_1 = require("./streams");
const errors_1 = require("../errors");
const collections_1 = require("../collections");
class MetadataConverter {
    constructor(registry = new metadata_registry_1.RegistryAccess()) {
        this.registry = registry;
    }
    /**
     * Convert metadata components to another SFDX file format.
     *
     * @param components Components to convert
     * @param targetFormat Format to convert the component files to
     * @param output Configuration for outputting the converted files
     */
    convert(components, targetFormat, output) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // it's possible the components came from a component set, so this may be redundant in some cases...
                const manifestContents = new collections_1.ComponentSet(components, this.registry).getPackageXml();
                const isSource = targetFormat === 'source';
                const tasks = [];
                let writer;
                let mergeSet;
                let packagePath;
                switch (output.type) {
                    case 'directory':
                        packagePath = this.getPackagePath(output);
                        writer = new streams_1.StandardWriter(packagePath);
                        if (!isSource) {
                            const manifestPath = path_1.join(packagePath, MetadataConverter.PACKAGE_XML_FILE);
                            tasks.push(fs_1.promises.writeFile(manifestPath, manifestContents));
                        }
                        break;
                    case 'zip':
                        packagePath = this.getPackagePath(output);
                        writer = new streams_1.ZipWriter(packagePath);
                        if (!isSource) {
                            writer.addToZip(manifestContents, MetadataConverter.PACKAGE_XML_FILE);
                        }
                        break;
                    case 'merge':
                        if (!isSource) {
                            throw new errors_1.LibraryError('error_merge_metadata_target_unsupported');
                        }
                        mergeSet = new collections_1.ComponentSet();
                        // since child components are composed in metadata format, we need to merge using the parent
                        for (const component of output.mergeWith) {
                            mergeSet.add((_a = component.parent, (_a !== null && _a !== void 0 ? _a : component)));
                        }
                        writer = new streams_1.StandardWriter(output.defaultDirectory);
                        break;
                }
                const conversionPipeline = streams_1.pipeline(new streams_1.ComponentReader(components), new streams_1.ComponentConverter(targetFormat, this.registry, mergeSet), writer);
                tasks.push(conversionPipeline);
                yield Promise.all(tasks);
                const result = { packagePath };
                if (output.type === 'zip' && !packagePath) {
                    result.zipBuffer = writer.buffer;
                }
                else if (output.type !== 'zip') {
                    result.converted = writer.converted;
                }
                return result;
            }
            catch (e) {
                throw new errors_1.ConversionError(e);
            }
        });
    }
    getPackagePath(outputConfig) {
        let packagePath;
        const { outputDirectory, packageName, type } = outputConfig;
        if (outputDirectory) {
            const name = packageName || `${MetadataConverter.DEFAULT_PACKAGE_PREFIX}_${Date.now()}`;
            packagePath = path_1.join(outputDirectory, name);
            if (type === 'zip') {
                packagePath += '.zip';
                fileSystemHandler_1.ensureDirectoryExists(path_1.dirname(packagePath));
            }
            else {
                fileSystemHandler_1.ensureDirectoryExists(packagePath);
            }
        }
        return packagePath;
    }
}
exports.MetadataConverter = MetadataConverter;
MetadataConverter.PACKAGE_XML_FILE = 'package.xml';
MetadataConverter.DEFAULT_PACKAGE_PREFIX = 'metadataPackage';
//# sourceMappingURL=metadataConverter.js.map