"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const fast_xml_parser_1 = require("fast-xml-parser");
const client_1 = require("../client");
const common_1 = require("../common");
const errors_1 = require("../errors");
const metadata_registry_1 = require("../metadata-registry");
class ComponentSet {
    constructor(components = [], registry = new metadata_registry_1.RegistryAccess()) {
        this.components = new Map();
        this.registry = registry;
        this.apiVersion = this.registry.apiVersion;
        for (const component of components) {
            this.add(component);
        }
    }
    /**
     * Create a set by resolving components from source.
     *
     * @param fsPath Path to resolve components from
     * @param options
     */
    static fromSource(fsPath, options = {}) {
        const ws = new ComponentSet(undefined, options.registry);
        ws.resolveSourceComponents(fsPath, options);
        return ws;
    }
    /**
     * Create a set by reading a manifest file in xml format. Optionally, specify a file path
     * with the `resolve` option to resolve source files for the components.
     *
     * ```
     * WorkingSet.fromManifestFile('/path/to/package.xml', {
     *  resolve: '/path/to/force-app'
     * });
     * ```
     *
     * @param fsPath Path to xml file
     * @param options
     */
    static fromManifestFile(fsPath, options = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const registry = (_a = options.registry, (_a !== null && _a !== void 0 ? _a : new metadata_registry_1.RegistryAccess()));
            const tree = (_b = options.tree, (_b !== null && _b !== void 0 ? _b : new metadata_registry_1.NodeFSTreeContainer()));
            const shouldResolve = !!options.resolve;
            const ws = new ComponentSet(undefined, registry);
            const filterSet = new ComponentSet(undefined, registry);
            const file = yield tree.readFile(fsPath);
            const manifestObj = fast_xml_parser_1.parse(file.toString(), {
                stopNodes: ['version'],
            });
            ws.apiVersion = manifestObj.Package.version;
            for (const component of ComponentSet.getComponentsFromManifestObject(manifestObj, registry)) {
                if (shouldResolve) {
                    filterSet.add(component);
                }
                const memberIsWildcard = component.fullName === ComponentSet.WILDCARD;
                if (!memberIsWildcard || ((_c = options) === null || _c === void 0 ? void 0 : _c.literalWildcard) || !shouldResolve) {
                    ws.add(component);
                }
            }
            if (shouldResolve) {
                // if it's a string, don't iterate over the characters
                const toResolve = typeof options.resolve === 'string' ? [options.resolve] : options.resolve;
                for (const fsPath of toResolve) {
                    ws.resolveSourceComponents(fsPath, {
                        tree,
                        filter: filterSet,
                    });
                }
            }
            return ws;
        });
    }
    static *getComponentsFromManifestObject(obj, registry) {
        const { types } = obj.Package;
        const typeMembers = Array.isArray(types) ? types : [types];
        for (const { name: typeName, members } of typeMembers) {
            const fullNames = Array.isArray(members) ? members : [members];
            for (const fullName of fullNames) {
                let type = registry.getTypeByName(typeName);
                // if there is no / delimiter and it's a type in folders, infer folder component
                if (type.folderType && !fullName.includes('/')) {
                    type = registry.getTypeByName(type.folderType);
                }
                yield {
                    fullName,
                    type,
                };
            }
        }
    }
    /**
     * Deploy components in the set to an org. The components must be backed by source files.
     * Deploying with a username requires local AuthInfo from @salesforce/core, usually created
     * after authenticating with the Salesforce CLI.
     *
     * @param usernameOrConnection Username or connection to deploy components with.
     * @param options
     */
    deploy(usernameOrConnection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const toDeploy = Array.from(this.getSourceComponents());
            if (toDeploy.length === 0) {
                throw new errors_1.ComponentSetError('error_no_source_to_deploy');
            }
            const connection = yield this.getConnection(usernameOrConnection);
            const client = new client_1.SourceClient(connection, new metadata_registry_1.MetadataResolver());
            return client.metadata.deploy(toDeploy, options);
        });
    }
    /**
     * Retrieve components in the set from an org. Components are not required to be backed by
     * source files. Retrieving with a username requires local AuthInfo from @salesforce/core,
     * usually created after authenticating with the Salesforce CLI.
     *
     * @param usernameOrConnection Username or Connection to retrieve with.
     * @param output Directory to retrieve to.
     * @param options
     */
    retrieve(usernameOrConnection, output, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.size === 0) {
                throw new errors_1.ComponentSetError('error_no_components_to_retrieve');
            }
            const connection = yield this.getConnection(usernameOrConnection);
            const client = new client_1.SourceClient(connection, new metadata_registry_1.MetadataResolver());
            return client.metadata.retrieve({
                components: this,
                merge: (_a = options) === null || _a === void 0 ? void 0 : _a.merge,
                output,
                wait: (_b = options) === null || _b === void 0 ? void 0 : _b.wait,
            });
        });
    }
    /**
     * Get an object representation of a package manifest based on the set components.
     */
    getObject() {
        const typeMap = new Map();
        for (const key of this.components.keys()) {
            const [typeId, fullName] = key.split(ComponentSet.KEY_DELIMITER);
            let type = this.registry.getTypeByName(typeId);
            if (type.folderContentType) {
                type = this.registry.getTypeByName(type.folderContentType);
            }
            if (!typeMap.has(type.name)) {
                typeMap.set(type.name, []);
            }
            typeMap.get(type.name).push(fullName);
        }
        const typeMembers = [];
        for (const [typeName, members] of typeMap.entries()) {
            typeMembers.push({ members, name: typeName });
        }
        return {
            Package: {
                types: typeMembers,
                version: this.apiVersion,
            },
        };
    }
    /**
     * Resolve source backed components and add them to the set.
     *
     * @param fsPath: File path to resolve
     * @param options
     */
    resolveSourceComponents(fsPath, options = {}) {
        var _a, _b;
        let filterSet;
        if ((_a = options) === null || _a === void 0 ? void 0 : _a.filter) {
            const { filter } = options;
            filterSet = filter instanceof ComponentSet ? filter : new ComponentSet(filter);
        }
        // TODO: move most of this logic to resolver W-8023153
        const resolver = new metadata_registry_1.MetadataResolver(this.registry, (_b = options) === null || _b === void 0 ? void 0 : _b.tree);
        const resolved = resolver.getComponentsFromPath(fsPath);
        const sourceComponents = new ComponentSet();
        for (const component of resolved) {
            if (filterSet) {
                const includedInWildcard = filterSet.has({
                    fullName: ComponentSet.WILDCARD,
                    type: component.type,
                });
                const parentInFilter = component.parent &&
                    (filterSet.has(component.parent) ||
                        filterSet.has({
                            fullName: ComponentSet.WILDCARD,
                            type: component.parent.type,
                        }));
                if (filterSet.has(component) || includedInWildcard || parentInFilter) {
                    this.add(component);
                    sourceComponents.add(component);
                }
                else {
                    // have to check for any individually addressed children in the filter set
                    for (const childComponent of component.getChildren()) {
                        if (filterSet.has(childComponent)) {
                            this.add(childComponent);
                            sourceComponents.add(childComponent);
                        }
                    }
                }
            }
            else {
                this.add(component);
                sourceComponents.add(component);
            }
        }
        return sourceComponents;
    }
    /**
     * Create a manifest in xml format (package.xml) based on the set components.
     *
     * @param indentation Number of spaces to indent lines by.
     */
    getPackageXml(indentation = 4) {
        const j2x = new fast_xml_parser_1.j2xParser({
            format: true,
            indentBy: new Array(indentation + 1).join(' '),
            ignoreAttributes: false,
        });
        const toParse = this.getObject();
        toParse.Package[common_1.XML_NS_KEY] = common_1.XML_NS_URL;
        return common_1.XML_DECL.concat(j2x.parse(toParse));
    }
    *getSourceComponents(forMember) {
        var _a;
        let iter;
        if (forMember) {
            // filter optimization
            const memberCollection = this.components.get(this.simpleKey(forMember));
            iter = ((_a = memberCollection) === null || _a === void 0 ? void 0 : _a.size) > 0 ? memberCollection.values() : [];
        }
        else {
            iter = this;
        }
        for (const component of iter) {
            if (component instanceof metadata_registry_1.SourceComponent) {
                yield component;
            }
        }
    }
    add(component) {
        const key = this.simpleKey(component);
        if (!this.components.has(key)) {
            this.components.set(key, new Map());
        }
        if (component instanceof metadata_registry_1.SourceComponent) {
            this.components.get(key).set(this.sourceKey(component), component);
        }
    }
    has(component) {
        return this.components.has(this.simpleKey(component));
    }
    *[Symbol.iterator]() {
        for (const [key, sourceComponents] of this.components.entries()) {
            if (sourceComponents.size === 0) {
                const [typeName, fullName] = key.split(ComponentSet.KEY_DELIMITER);
                yield {
                    fullName,
                    type: this.registry.getTypeByName(typeName),
                };
            }
            else {
                for (const component of sourceComponents.values()) {
                    yield component;
                }
            }
        }
    }
    get size() {
        let size = 0;
        for (const collection of this.components.values()) {
            // just having an entry in the parent map counts as 1
            size += collection.size === 0 ? 1 : collection.size;
        }
        return size;
    }
    getConnection(auth) {
        return __awaiter(this, void 0, void 0, function* () {
            return typeof auth === 'string'
                ? yield core_1.Connection.create({
                    authInfo: yield core_1.AuthInfo.create({ username: auth }),
                })
                : auth;
        });
    }
    sourceKey(component) {
        const { fullName, type, xml, content } = component;
        return `${type.name}${fullName}${(xml !== null && xml !== void 0 ? xml : '')}${(content !== null && content !== void 0 ? content : '')}`;
    }
    simpleKey(component) {
        const typeName = typeof component.type === 'string' ? component.type.toLowerCase().trim() : component.type.id;
        return `${typeName}${ComponentSet.KEY_DELIMITER}${component.fullName}`;
    }
}
exports.ComponentSet = ComponentSet;
ComponentSet.WILDCARD = '*';
ComponentSet.KEY_DELIMITER = '#';
//# sourceMappingURL=componentSet.js.map