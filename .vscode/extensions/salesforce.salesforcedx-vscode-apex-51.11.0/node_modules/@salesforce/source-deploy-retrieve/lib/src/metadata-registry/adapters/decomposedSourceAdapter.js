"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const mixedContentSourceAdapter_1 = require("./mixedContentSourceAdapter");
const registry_1 = require("../../utils/registry");
const sourceComponent_1 = require("../sourceComponent");
const utils_1 = require("../../utils");
/**
 * Handles decomposed types. A flavor of mixed content where a component can
 * have additional -meta.xml files that represent child components of the main
 * component.
 *
 * __Example Types__:
 *
 * CustomObject, CustomObjectTranslation
 *
 * __Example Structures__:
 *
 *```text
 * foos/
 * ├── MyFoo__c/
 * |   ├── MyFoo__c.foo-meta.xml
 * |   ├── bars/
 * |      ├── a.bar-meta.xml
 * |      ├── b.bar-meta.xml
 * |      ├── c.bar-meta.xml
 *
 * foos/
 * ├── MyFoo__c/
 * |   ├── a.bar-meta.xml
 * |   ├── MyFoo__c.foo-meta.xml
 * |   ├── b.bar-meta.xml
 * |   ├── c.bar-meta.xml
 *```
 */
class DecomposedSourceAdapter extends mixedContentSourceAdapter_1.MixedContentSourceAdapter {
    constructor() {
        super(...arguments);
        this.ownFolder = true;
        this.metadataWithContent = false;
    }
    /**
     * If the trigger turns out to be part of a child component, `populate` will build
     * the child component, set its parent property to the one created by the
     * `BaseSourceAdapter`, and return the child component instead.
     */
    populate(trigger, component, isResolvingSource) {
        const metaXml = registry_1.parseMetadataXml(trigger);
        if (metaXml) {
            const pathToContent = this.trimPathToContent(trigger);
            const childTypeId = this.type.children.suffixes[metaXml.suffix];
            const triggerIsAChild = !!childTypeId;
            const strategy = this.type.strategies.decomposition;
            if (triggerIsAChild &&
                (strategy === "folderPerType" /* FolderPerType */ || isResolvingSource)) {
                let parent = component;
                if (!parent) {
                    parent = new sourceComponent_1.SourceComponent({
                        name: utils_1.baseName(pathToContent),
                        type: this.type,
                    }, this.tree, this.forceIgnore);
                }
                parent.content = pathToContent;
                return new sourceComponent_1.SourceComponent({
                    name: metaXml.fullName,
                    type: this.type.children.types[childTypeId],
                    xml: trigger,
                    parent,
                }, this.tree, this.forceIgnore);
            }
            if (!triggerIsAChild) {
                component.content = pathToContent;
            }
        }
        return component;
    }
}
exports.DecomposedSourceAdapter = DecomposedSourceAdapter;
//# sourceMappingURL=decomposedSourceAdapter.js.map