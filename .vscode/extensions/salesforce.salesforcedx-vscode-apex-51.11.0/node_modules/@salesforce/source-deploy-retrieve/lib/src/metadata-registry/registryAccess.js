"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const _1 = require(".");
const errors_1 = require("../errors");
/**
 * Accessor for interacting with data that conforms to the MetadataRegistry schema.
 */
class RegistryAccess {
    constructor(registry = _1.registryData) {
        this.registry = registry;
    }
    getTypeByName(name) {
        var _a;
        const lower = name.toLowerCase().trim();
        if (this.registry.childTypes[lower]) {
            const parentTypeId = this.registry.childTypes[lower];
            const childType = (_a = this.registry.types[parentTypeId].children) === null || _a === void 0 ? void 0 : _a.types[lower];
            if (childType) {
                return childType;
            }
            throw new errors_1.RegistryError('error_missing_child_type_definition', [parentTypeId, lower]);
        }
        if (!this.registry.types[lower]) {
            throw new errors_1.RegistryError('error_missing_type_definition', lower);
        }
        return this.registry.types[lower];
    }
    getTypeBySuffix(suffix) {
        if (this.registry.suffixes[suffix]) {
            const typeId = this.registry.suffixes[suffix];
            return this.getTypeByName(typeId);
        }
    }
    findType(predicate) {
        return Object.values(this.registry.types).find(predicate);
    }
    /**
     * Get the types whose component files require having a parent directory named after
     * their assigned directory name.
     */
    getStrictFolderTypes() {
        return Object.values(this.registry.strictDirectoryNames).map((typeId) => this.registry.types[typeId]);
    }
    get apiVersion() {
        return this.registry.apiVersion;
    }
}
exports.RegistryAccess = RegistryAccess;
//# sourceMappingURL=registryAccess.js.map