import { WriteInfo, WriterFormat } from './types';
import { SourceComponent } from '../metadata-registry';
import { MetadataComponent } from '../common';
import { ComponentSet } from '../collections';
declare abstract class ConvertTransactionFinalizer<T> {
    protected abstract _state: T;
    setState(props: (state: T) => void): void;
    get state(): T;
    abstract finalize(): Promise<WriterFormat[]>;
}
export interface RecompositionState {
    [componentKey: string]: {
        /**
         * Parent component that children are rolled up into
         */
        component?: SourceComponent;
        /**
         * Children to be rolled up into the parent file
         */
        children?: ComponentSet;
    };
}
/**
 * Merges child components that share the same parent in the conversion pipeline
 * into a single file.
 */
declare class RecompositionFinalizer extends ConvertTransactionFinalizer<RecompositionState> {
    protected _state: RecompositionState;
    finalize(): Promise<WriterFormat[]>;
    private recompose;
}
export interface DecompositionState {
    [componentKey: string]: {
        foundMerge?: boolean;
        writeInfo?: WriteInfo;
        origin?: MetadataComponent;
    };
}
/**
 * Creates write infos for any children that haven't been written yet. Children may
 * delay being written in order to find potential existing children to merge
 * with in the conversion pipeline.
 */
declare class DecompositionFinalizer extends ConvertTransactionFinalizer<DecompositionState> {
    protected _state: DecompositionState;
    finalize(): Promise<WriterFormat[]>;
}
/**
 * A state manager over the course of a single metadata conversion call.
 */
export declare class ConvertContext {
    readonly decomposition: DecompositionFinalizer;
    readonly recomposition: RecompositionFinalizer;
    executeFinalizers(): AsyncIterable<WriterFormat[]>;
}
export {};
