import { TreeContainer } from './types';
import { SourceComponent } from './sourceComponent';
import { RegistryAccess } from './registryAccess';
/**
 * Resolver for metadata type and component objects.
 */
export declare class MetadataResolver {
    private forceIgnore;
    private sourceAdapterFactory;
    private tree;
    private registry;
    /**
     * @param registry Custom registry data
     * @param tree `TreeContainer` to traverse with
     */
    constructor(registry?: RegistryAccess, tree?: TreeContainer);
    /**
     * Get the metadata component(s) from a file path.
     *
     * @param fsPath File path for a piece of metadata
     */
    getComponentsFromPath(fsPath: string): SourceComponent[];
    private getComponentsFromPathRecursive;
    private resolveComponent;
    private resolveType;
    /**
     * Whether or not a directory that represents a single component should be resolved as one,
     * or if it should be walked for additional components.
     *
     * If a type can be determined from a directory path, and the end part of the path isn't
     * the directoryName of the type itself, infer the path is part of a mixedContent component
     *
     * @param dirPath Path to a directory
     */
    private resolveDirectoryAsComponent;
    /**
     * Any file with a registered suffix is potentially a content metadata file.
     *
     * @param fsPath File path of a potential content metadata file
     */
    private parseAsContentMetadataXml;
    /**
     * Identify metadata xml for a folder component:
     *    .../email/TestFolder-meta.xml
     *
     * Do not match this pattern:
     *    .../tabs/TestFolder.tab-meta.xml
     */
    private parseAsFolderMetadataXml;
    private isMetadata;
}
