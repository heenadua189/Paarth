"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_registry_1 = require("../metadata-registry");
const path_1 = require("path");
class DiagnosticUtil {
    constructor(api) {
        this.api = api;
    }
    setRetrieveDiagnostic(message, componentRetrieval) {
        componentRetrieval.diagnostics = {
            message: message,
            type: 'Error',
            filePath: componentRetrieval.component.content,
        };
        return componentRetrieval;
    }
    setDeployDiagnostic(componentDeployment, message) {
        const { name: typeName } = componentDeployment.component.type;
        switch (typeName) {
            case metadata_registry_1.registryData.types.lightningcomponentbundle.name:
                return this.parseLwc(componentDeployment, message);
            case metadata_registry_1.registryData.types.auradefinitionbundle.name:
                return this.parseAura(componentDeployment, message);
            default:
                if (typeof message !== 'string') {
                    return this.parseDefault(componentDeployment, message);
                }
        }
    }
    parseLwc(componentDeployment, message) {
        const problem = typeof message === 'string' ? message : message.problem;
        const diagnostic = {
            message: problem,
            type: 'Error',
        };
        if (this.api === 'metadata') {
            const deployMessage = message;
            if (deployMessage.fileName) {
                diagnostic.filePath = componentDeployment.component
                    .walkContent()
                    .find((f) => f.includes(message.fileName));
            }
            const matches = problem.match(/(\[Line: (\d+), Col: (\d+)] )?(.*)/);
            if (matches && matches[2] && matches[3] && matches[4]) {
                diagnostic.lineNumber = Number(matches[2]);
                diagnostic.columnNumber = Number(matches[3]);
                diagnostic.message = matches[4];
            }
            else {
                diagnostic.message = problem;
            }
        }
        else {
            try {
                const pathParts = problem.split(/[\s\n\t]+/);
                const msgStartIndex = pathParts.findIndex((part) => part.includes(':'));
                const fileObject = pathParts[msgStartIndex];
                const errLocation = fileObject.slice(fileObject.indexOf(':') + 1);
                const fileName = fileObject.slice(0, fileObject.indexOf(':'));
                diagnostic.message = pathParts.slice(msgStartIndex + 2).join(' ');
                diagnostic.filePath = componentDeployment.component
                    .walkContent()
                    .find((f) => f.includes(fileName));
                diagnostic.lineNumber = Number(errLocation.split(',')[0]);
                diagnostic.columnNumber = Number(errLocation.split(',')[1]);
            }
            catch (e) {
                // TODO: log error with parsing error message
                diagnostic.message = problem;
            }
        }
        componentDeployment.diagnostics.push(diagnostic);
        return componentDeployment;
    }
    parseAura(componentDeployment, message) {
        const problem = typeof message === 'string' ? message : message.problem;
        const diagnostic = {
            message: problem,
            type: 'Error',
        };
        let filePath;
        if (this.api === 'tooling') {
            const errorParts = problem.split(' ');
            const fileType = errorParts.find((part) => {
                part = part.toLowerCase();
                return part.includes('controller') || part.includes('renderer') || part.includes('helper');
            });
            filePath = fileType
                ? componentDeployment.component
                    .walkContent()
                    .find((s) => s.toLowerCase().includes(fileType.toLowerCase()))
                : undefined;
        }
        else {
            const deployMessage = message;
            if (deployMessage.fileName) {
                filePath = componentDeployment.component
                    .walkContent()
                    .find((f) => f.endsWith(path_1.basename(deployMessage.fileName)));
            }
        }
        if (filePath) {
            diagnostic.filePath = filePath;
            const matches = problem.match(/(\d+),\s?(\d+)/);
            if (matches) {
                diagnostic.lineNumber = Number(matches[1]);
                diagnostic.columnNumber = Number(matches[2]);
            }
        }
        diagnostic.message = problem;
        componentDeployment.diagnostics.push(diagnostic);
        return componentDeployment;
    }
    parseDefault(componentDeployment, message) {
        const diagnostic = {
            message: message.problem,
            type: message.problemType,
        };
        if (message.fileName) {
            const localProblemFile = componentDeployment.component
                .walkContent()
                .find((f) => f.endsWith(path_1.basename(message.fileName)));
            diagnostic.filePath = localProblemFile;
        }
        if (message.lineNumber && message.columnNumber) {
            diagnostic.lineNumber = Number(message.lineNumber);
            diagnostic.columnNumber = Number(message.columnNumber);
        }
        componentDeployment.diagnostics.push(diagnostic);
        return componentDeployment;
    }
}
exports.DiagnosticUtil = DiagnosticUtil;
//# sourceMappingURL=diagnosticUtil.js.map