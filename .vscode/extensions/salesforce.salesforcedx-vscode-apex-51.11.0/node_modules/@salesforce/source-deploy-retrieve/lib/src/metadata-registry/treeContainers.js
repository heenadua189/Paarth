"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const utils_1 = require("../utils");
const registry_1 = require("../utils/registry");
const fs_1 = require("fs");
const errors_1 = require("../errors");
const unzipper = require("unzipper");
/**
 * An extendable base class for implementing the `TreeContainer` interface
 */
class BaseTreeContainer {
    find(fileType, fullName, dir) {
        const fileName = this.readDirectory(dir).find((entry) => {
            const parsed = registry_1.parseMetadataXml(path_1.join(dir, entry));
            const metaXmlCondition = fileType === 'metadata' ? !!parsed : !parsed;
            return utils_1.baseName(entry) === fullName && metaXmlCondition;
        });
        if (fileName) {
            return path_1.join(dir, fileName);
        }
    }
}
exports.BaseTreeContainer = BaseTreeContainer;
class NodeFSTreeContainer extends BaseTreeContainer {
    isDirectory(fsPath) {
        return fs_1.lstatSync(fsPath).isDirectory();
    }
    exists(fsPath) {
        return fs_1.existsSync(fsPath);
    }
    readDirectory(fsPath) {
        return fs_1.readdirSync(fsPath);
    }
    readFile(fsPath) {
        // significant performance increase using sync instead of fs.promise version
        return Promise.resolve(fs_1.readFileSync(fsPath));
    }
    stream(fsPath) {
        return fs_1.createReadStream(fsPath);
    }
}
exports.NodeFSTreeContainer = NodeFSTreeContainer;
class ZipTreeContainer extends BaseTreeContainer {
    constructor(directory) {
        super();
        this.tree = new Map();
        this.populate(directory);
    }
    static create(buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            const directory = yield unzipper.Open.buffer(buffer);
            return new ZipTreeContainer(directory);
        });
    }
    exists(fsPath) {
        return this.tree.has(fsPath);
    }
    isDirectory(fsPath) {
        if (this.exists(fsPath)) {
            return Array.isArray(this.tree.get(fsPath));
        }
        throw new errors_1.LibraryError('error_path_not_found', fsPath);
    }
    readDirectory(fsPath) {
        if (this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).map((entry) => path_1.basename(entry.path));
        }
        throw new errors_1.LibraryError('error_expected_directory_path', fsPath);
    }
    readFile(fsPath) {
        if (!this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).buffer();
        }
        throw new errors_1.LibraryError('error_expected_file_path', fsPath);
    }
    stream(fsPath) {
        if (!this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).stream();
        }
        throw new errors_1.LibraryError('error_no_directory_stream', this.constructor.name);
    }
    populate(directory) {
        for (const { path, type, stream, buffer } of directory.files) {
            if (type === 'File') {
                // normalize path to use OS separator since zip entries always use forward slash
                const entry = { path: path_1.normalize(path), stream, buffer };
                this.tree.set(entry.path, entry);
                this.ensureDirPathExists(entry);
            }
        }
    }
    ensureDirPathExists(entry) {
        const dirPath = path_1.dirname(entry.path);
        if (dirPath === entry.path) {
            return;
        }
        else if (!this.exists(dirPath)) {
            this.tree.set(dirPath, [entry]);
            this.ensureDirPathExists({ path: dirPath });
        }
        else {
            this.tree.get(dirPath).push(entry);
        }
    }
}
exports.ZipTreeContainer = ZipTreeContainer;
class VirtualTreeContainer extends BaseTreeContainer {
    constructor(virtualFs) {
        super();
        this.tree = new Map();
        this.fileContents = new Map();
        this.populate(virtualFs);
    }
    isDirectory(fsPath) {
        if (this.exists(fsPath)) {
            return this.tree.has(fsPath);
        }
        throw new errors_1.LibraryError('error_path_not_found', fsPath);
    }
    exists(fsPath) {
        const files = this.tree.get(path_1.dirname(fsPath));
        const isFile = files && files.has(fsPath);
        return isFile || this.tree.has(fsPath);
    }
    readDirectory(fsPath) {
        if (this.isDirectory(fsPath)) {
            return Array.from(this.tree.get(fsPath)).map((p) => path_1.basename(p));
        }
        throw new errors_1.LibraryError('error_expected_directory_path', fsPath);
    }
    readFile(fsPath) {
        if (this.exists(fsPath)) {
            let data = this.fileContents.get(fsPath);
            if (!data) {
                data = Buffer.from('');
                this.fileContents.set(fsPath, data);
            }
            return Promise.resolve(data);
        }
        throw new errors_1.LibraryError('error_path_not_found', fsPath);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stream(fsPath) {
        throw new Error('Method not implemented');
    }
    populate(virtualFs) {
        for (const dir of virtualFs) {
            const { dirPath, children } = dir;
            this.tree.set(dirPath, new Set());
            for (const child of children) {
                let childPath;
                let childData;
                if (typeof child === 'string') {
                    childPath = path_1.join(dirPath, child);
                }
                else {
                    childPath = path_1.join(dirPath, child.name);
                    childData = child.data;
                }
                this.tree.get(dirPath).add(childPath);
                if (childData) {
                    this.fileContents.set(childPath, childData);
                }
            }
        }
    }
}
exports.VirtualTreeContainer = VirtualTreeContainer;
//# sourceMappingURL=treeContainers.js.map