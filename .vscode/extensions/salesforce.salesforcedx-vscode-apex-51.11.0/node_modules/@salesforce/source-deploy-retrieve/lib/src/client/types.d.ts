import { Connection } from '@salesforce/core';
import { ComponentSet } from '../collections';
import { PackageTypeMembers } from '../collections/types';
import { MetadataComponent, SourcePath } from '../common/types';
import { MetadataResolver, RegistryAccess, SourceComponent } from '../metadata-registry';
export declare type RecordId = string;
export declare type ComponentDeployment = {
    id?: string;
    component: SourceComponent;
    status: ComponentStatus;
    diagnostics: ComponentDiagnostic[];
};
export declare type ComponentRetrieval = {
    component: SourceComponent;
    status?: RetrieveStatus;
    diagnostics?: ComponentDiagnostic;
};
export declare type ComponentDiagnostic = {
    lineNumber?: number;
    columnNumber?: number;
    filePath?: SourcePath;
    message: string;
    type: 'Warning' | 'Error';
};
/**
 * Status of component during a deployment.
 */
export declare enum ComponentStatus {
    Created = "Created",
    Changed = "Changed",
    Unchanged = "Unchanged",
    Deleted = "Deleted",
    Failed = "Failed"
}
interface SourceApiResult {
    success: boolean;
}
export interface SourceDeployResult extends SourceApiResult {
    id: RecordId;
    components?: ComponentDeployment[];
    status: DeployStatus | ToolingDeployStatus;
}
export declare type RetrieveFailure = {
    component?: MetadataComponent;
    message: string;
};
export declare type RetrieveSuccess = {
    component: SourceComponent;
    properties?: FileProperties;
};
export interface SourceRetrieveResult extends SourceApiResult {
    id?: RecordId;
    successes: RetrieveSuccess[];
    failures: RetrieveFailure[];
    status: RetrieveStatus;
}
/**
 * Raw response returned from a checkDeployStatus call to the Metadata API
 */
export declare type DeployResult = {
    id: string;
    canceledBy?: string;
    canceledByName?: string;
    checkOnly: boolean;
    completedDate?: string;
    createdBy: string;
    createdByName: string;
    createdDate: string;
    details: DeployDetails;
    done: boolean;
    errorMessage?: string;
    errorStatusCode?: string;
    ignoreWarnings: boolean;
    lastModifiedDate: string;
    numberComponentErrors: number;
    numberComponentsDeployed: number;
    numberComponentsTotal: number;
    numberTestErrors: number;
    numberTestsCompleted: number;
    numberTestsTotal: number;
    runTestsEnabled: boolean;
    rollbackOnError: boolean;
    startDate?: string;
    stateDetail?: string;
    status: DeployStatus;
    success: boolean;
};
/**
 * Possible statuses of a metadata deploy operation.
 */
export declare enum DeployStatus {
    Pending = "Pending",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    SucceededPartial = "SucceededPartial",
    Failed = "Failed",
    Canceling = "Canceling",
    Canceled = "Canceled"
}
export declare type DeployDetails = {
    componentFailures?: DeployMessage[];
    componentSuccesses?: DeployMessage[];
};
declare type BooleanString = 'true' | 'false' | true | false;
export declare type DeployMessage = {
    changed: BooleanString;
    columnNumber?: string;
    componentType?: string;
    created: BooleanString;
    createdDate: string;
    deleted: BooleanString;
    fileName: string;
    fullName: string;
    id?: string;
    lineNumber?: string;
    problem?: string;
    problemType?: 'Warning' | 'Error';
    success: BooleanString;
};
export declare type RetrieveRequest = {
    apiVersion: string;
    packageNames?: string[];
    singlePackage?: boolean;
    specificFiles?: string[];
    unpackaged: {
        types: PackageTypeMembers[];
    };
};
export declare enum RetrieveStatus {
    Pending = "Pending",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    PartialSuccess = "PartialSuccess",
    Failed = "Failed"
}
export declare type RetrieveMessage = {
    fileName: string;
    problem: string;
};
declare enum ManageableState {
    Beta = "beta",
    Deleted = "deleted",
    Deprecated = "deprecated",
    DeprecatedEditable = "deprecatedEditable",
    Installed = "installed",
    InstalledEditable = "installedEditable",
    Released = "released",
    Unmanaged = "unmanaged"
}
export declare type FileProperties = {
    createdById: string;
    createdByName: string;
    createdDate: string;
    fileName: string;
    fullName: string;
    id: string;
    lastModifiedById: string;
    lastModifiedByName: string;
    lastModifiedDate: string;
    manageableState?: ManageableState;
    namespacePrefix?: string;
    type: string;
};
/**
 * Raw response returned from a checkRetrieveStatus call to the Metadata API
 */
export declare type RetrieveResult = {
    done: boolean;
    fileProperties: FileProperties[];
    id: string;
    status: RetrieveStatus;
    success: boolean;
    messages?: RetrieveMessage[] | RetrieveMessage;
    zipFile: string;
};
export declare type ContainerAsyncRequest = {
    Id: RecordId;
    DeployDetails?: DeployDetails;
    ErrorMsg?: string;
    State?: ToolingDeployStatus;
};
export declare const enum ToolingDeployStatus {
    Queued = "Queued",
    Invalidated = "Invalidated",
    Error = "Error",
    Aborted = "Aborted",
    Completed = "Completed",
    Failed = "Failed",
    CompletedPartial = "CompletedPartial"
}
export declare type QueryResult = {
    size: number;
    totalSize: number;
    done: boolean;
    queryLocator: string;
    entityTypeName: string;
    records: ApexRecord[] | AuraRecord[] | LWCRecord[] | VFRecord[];
};
export declare type ApexRecord = {
    Id: string;
    Name: string;
    NamespacePrefix: string;
    Body: string;
    ApiVersion: string;
    Status: string;
};
export declare type VFRecord = {
    Id: string;
    Name: string;
    NamespacePrefix: string;
    Markup: string;
    ApiVersion: string;
};
export declare type AuraRecord = {
    Id: string;
    DefType: string;
    Source: string;
    AuraDefinitionBundle: {
        ApiVersion: string;
        DeveloperName: string;
        NamespacePrefix: string;
    };
};
export declare type LWCRecord = {
    Id: string;
    FilePath: string;
    Source: string;
    LightningComponentBundle: {
        DeveloperName: string;
        NamespacePrefix: string;
    };
};
export interface DeployRetrieveClient {
    /**
     * Retrieve metadata components and wait for the result.
     *
     * @param options Specify `components`, `output` and other optionals
     */
    retrieve(options: RetrieveOptions): Promise<SourceRetrieveResult>;
    /**
     * Infer metadata components from source paths, retrieve them, and wait for the result.
     *
     * @param options Specify `paths`, `output` and other optionals
     */
    retrieveWithPaths(options: RetrievePathOptions): Promise<SourceRetrieveResult>;
    /**
     * Deploy metadata components and wait for result.
     *
     * @param filePath Paths to source files to deploy
     */
    deploy(components: SourceComponent | SourceComponent[]): Promise<SourceDeployResult>;
    /**
     * Infer metadata components from source path, deploy them, and wait for results.
     *
     * @param filePath Paths to source files to deploy
     */
    deployWithPaths(paths: SourcePath | SourcePath[]): Promise<SourceDeployResult>;
}
export declare abstract class BaseApi implements DeployRetrieveClient {
    protected connection: Connection;
    protected resolver: MetadataResolver;
    protected registry: RegistryAccess;
    constructor(connection: Connection, resolver: MetadataResolver, registry?: RegistryAccess);
    /**
     * @param options Specify `paths`, `output` and other optionals
     */
    abstract retrieveWithPaths(options: RetrievePathOptions): Promise<SourceRetrieveResult>;
    abstract retrieve(options: RetrieveOptions): Promise<SourceRetrieveResult>;
    abstract deploy(components: SourceComponent | SourceComponent[]): Promise<SourceDeployResult>;
    abstract deployWithPaths(paths: SourcePath | SourcePath[]): Promise<SourceDeployResult>;
}
declare type CommonOptions = {
    /**
     * Set the max number of seconds to wait for the operation.
     */
    wait?: number;
    namespace?: string;
    merge?: boolean;
};
declare type CommonRetrieveOptions = {
    /**
     * The directory to retrieve the components to.
     */
    output?: SourcePath;
    /**
     * Whether or not to merge and replace input components with the retrieved versions
     */
    merge?: boolean;
};
declare type CommonPathOptions = {
    /**
     * Source paths of the files to perform the operation on.
     */
    paths: SourcePath[];
};
export declare type RetrieveOptions = CommonOptions & CommonRetrieveOptions & {
    components: ComponentSet;
};
export declare type RetrievePathOptions = CommonOptions & CommonRetrieveOptions & CommonPathOptions;
export declare type ApiResult = {
    success: boolean;
    components: SourceComponent[];
    message?: string;
};
declare type WaitFlag = {
    wait?: number;
};
declare type NamespaceFlag = {
    namespace?: string;
};
export declare type MetadataApiDeployOptions = {
    allowMissingFiles?: boolean;
    autoUpdatePackage?: boolean;
    checkOnly?: boolean;
    ignoreWarnings?: boolean;
    performRetrieve?: boolean;
    purgeOnDelete?: boolean;
    rollbackOnError?: boolean;
    runAllTests?: boolean;
    runTests?: string[];
    singlePackage?: boolean;
};
export declare type MetadataDeployOptions = WaitFlag & {
    apiOptions?: MetadataApiDeployOptions;
};
export declare type ToolingDeployOptions = NamespaceFlag;
export declare type DeployPathOptions = CommonOptions & CommonPathOptions;
export {};
