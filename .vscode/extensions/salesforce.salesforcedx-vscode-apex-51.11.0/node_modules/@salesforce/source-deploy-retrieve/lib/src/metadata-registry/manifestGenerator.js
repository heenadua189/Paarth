"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const metadataResolver_1 = require("./metadataResolver");
const errors_1 = require("../errors");
const fs_1 = require("fs");
const registryAccess_1 = require("./registryAccess");
class ManifestGenerator {
    constructor(resolver = new metadataResolver_1.MetadataResolver(), registry = new registryAccess_1.RegistryAccess()) {
        this.packageModuleStart = '<Package xmlns="http://soap.sforce.com/2006/04/metadata">\n';
        this.packageModuleEnd = '</Package>\n';
        this.resolver = resolver;
        this.registry = registry;
    }
    createManifestFromPath(sourcePath, outputPath) {
        try {
            const mdComponents = this.resolver.getComponentsFromPath(sourcePath);
            fs_1.writeFileSync(outputPath, this.createManifest(mdComponents));
        }
        catch (err) {
            throw new errors_1.RegistryError('error_on_manifest_creation', [sourcePath, err]);
        }
    }
    createManifest(components, apiVersion = this.registry.apiVersion, indent = '  ') {
        let output = common_1.XML_DECL.concat(this.packageModuleStart);
        const metadataMap = this.createMetadataMap(components);
        for (const metadataType of metadataMap.keys()) {
            output = output.concat(`${indent}<types>\n`);
            for (const metadataName of metadataMap.get(metadataType)) {
                output = output.concat(`${indent}${indent}<members>${metadataName}</members>\n`);
            }
            output = output.concat(`${indent}${indent}<name>${metadataType}</name>\n`);
            output = output.concat(`${indent}</types>\n`);
        }
        output = output.concat(`${indent}<version>${apiVersion}</version>\n`, this.packageModuleEnd);
        return output;
    }
    createMetadataMap(components) {
        const metadataMap = new Map();
        for (const component of components) {
            const { fullName, type: { name: typeName }, } = component;
            if (metadataMap.has(typeName)) {
                const metadataNames = metadataMap.get(typeName);
                metadataNames.add(fullName);
                metadataMap.set(typeName, metadataNames);
            }
            else {
                const metadataNames = new Set();
                metadataNames.add(fullName);
                metadataMap.set(typeName, metadataNames);
            }
        }
        return metadataMap;
    }
}
exports.ManifestGenerator = ManifestGenerator;
//# sourceMappingURL=manifestGenerator.js.map