"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const types_1 = require("./types");
const convert_1 = require("../convert");
const errors_1 = require("../errors");
const metadata_registry_1 = require("../metadata-registry");
const diagnosticUtil_1 = require("./diagnosticUtil");
const treeContainers_1 = require("../metadata-registry/treeContainers");
const collections_1 = require("../collections");
exports.DEFAULT_API_OPTIONS = {
    rollbackOnError: true,
    ignoreWarnings: false,
    checkOnly: false,
    singlePackage: true,
};
class MetadataApi extends types_1.BaseApi {
    deploy(components, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataComponents = Array.isArray(components) ? components : [components];
            const converter = new convert_1.MetadataConverter();
            const { zipBuffer } = yield converter.convert(metadataComponents, 'metadata', { type: 'zip' });
            const deployID = yield this.metadataDeployID(zipBuffer, options);
            const deployStatusPoll = this.metadataDeployStatusPoll(deployID, options);
            const componentDeploymentMap = new Map();
            for (const component of metadataComponents) {
                componentDeploymentMap.set(`${component.type.name}:${component.fullName}`, {
                    status: types_1.ComponentStatus.Unchanged,
                    component,
                    diagnostics: [],
                });
            }
            const result = yield deployStatusPoll;
            return this.buildSourceDeployResult(componentDeploymentMap, result);
        });
    }
    deployWithPaths(paths, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const components = this.resolver.getComponentsFromPath(paths);
            return this.deploy(components, options);
        });
    }
    retrieveWithPaths(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const components = new collections_1.ComponentSet(undefined, this.registry);
            for (const filepath of options.paths) {
                components.resolveSourceComponents(filepath);
            }
            const retrieveOptions = { components };
            return this.retrieve(Object.assign(retrieveOptions, options));
        });
    }
    retrieve(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let components = [];
            const retrieveRequest = this.formatRetrieveRequest(options.components);
            const retrieveResult = yield this.getRetrievedResult(retrieveRequest, options);
            if (retrieveResult.status === types_1.RetrieveStatus.Succeeded) {
                const tree = yield treeContainers_1.ZipTreeContainer.create(Buffer.from(retrieveResult.zipFile, 'base64'));
                const zipComponents = new metadata_registry_1.MetadataResolver(undefined, tree).getComponentsFromPath('.');
                components = yield this.getConvertedComponents(zipComponents, options);
            }
            const sourceRetrieveResult = this.buildSourceRetrieveResult(retrieveResult, components);
            return sourceRetrieveResult;
        });
    }
    formatRetrieveRequest(components) {
        const componentSet = components instanceof collections_1.ComponentSet ? components : new collections_1.ComponentSet(components, this.registry);
        const retrieveRequest = {
            apiVersion: this.registry.apiVersion,
            unpackaged: {
                types: componentSet.getObject().Package.types,
            },
        };
        return retrieveRequest;
    }
    getRetrievedResult(retrieveRequest, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore required callback
            const retrieveId = (yield this.connection.metadata.retrieve(retrieveRequest)).id;
            const retrieveResult = yield this.metadataRetrieveStatusPoll(retrieveId, options);
            return retrieveResult;
        });
    }
    metadataRetrieveStatusPoll(retrieveID, options, interval = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            const wait = (interval) => {
                return new Promise((resolve) => {
                    setTimeout(resolve, interval);
                });
            };
            const timeout = !options || !options.wait ? 10000 : options.wait;
            const endTime = Date.now() + timeout;
            let triedOnce = false;
            do {
                if (triedOnce) {
                    yield wait(interval);
                }
                try {
                    // Recasting to use the library's RetrieveResult type
                    result = (yield this.connection.metadata.checkRetrieveStatus(retrieveID));
                }
                catch (e) {
                    throw new errors_1.RetrieveError('md_request_fail', e);
                }
                switch (result.status) {
                    case types_1.RetrieveStatus.Succeeded:
                    case types_1.RetrieveStatus.Failed:
                        return result;
                    case types_1.RetrieveStatus.InProgress:
                }
                triedOnce = true;
            } while (Date.now() < endTime);
            return result;
        });
    }
    buildSourceRetrieveResult(retrieveResult, retrievedComponents) {
        const retrievedSet = new collections_1.ComponentSet(retrievedComponents, this.registry);
        const successes = [];
        const failures = [];
        if (retrieveResult.messages) {
            const retrieveMessages = Array.isArray(retrieveResult.messages)
                ? retrieveResult.messages
                : [retrieveResult.messages];
            for (const message of retrieveMessages) {
                // match type name and fullname of problem component
                const matches = message.problem.match(/.+'(.+)'.+'(.+)'/);
                if (matches) {
                    const [typeName, fullName] = matches.slice(1);
                    failures.push({
                        component: {
                            fullName,
                            type: this.registry.getTypeByName(typeName),
                        },
                        message: message.problem,
                    });
                }
                else {
                    failures.push({ message: message.problem });
                }
            }
        }
        if (retrieveResult.fileProperties) {
            const fileProperties = Array.isArray(retrieveResult.fileProperties)
                ? retrieveResult.fileProperties
                : [retrieveResult.fileProperties];
            for (const properties of fileProperties) {
                // not interested in the "Package" component at this time
                if (properties.type === 'Package') {
                    continue;
                }
                successes.push({
                    properties,
                    component: retrievedSet
                        .getSourceComponents({
                        fullName: properties.fullName,
                        type: this.registry.getTypeByName(properties.type),
                    })
                        .next().value,
                });
            }
        }
        let status = retrieveResult.status;
        if (failures.length > 0) {
            if (successes.length > 0) {
                status = types_1.RetrieveStatus.PartialSuccess;
            }
            else {
                status = types_1.RetrieveStatus.Failed;
            }
        }
        return {
            id: retrieveResult.id,
            status,
            successes,
            failures,
            success: status === types_1.RetrieveStatus.Succeeded || status === types_1.RetrieveStatus.PartialSuccess,
        };
    }
    getConvertedComponents(retrievedComponents, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const converter = new convert_1.MetadataConverter();
            const outputConfig = options.merge
                ? {
                    type: 'merge',
                    mergeWith: options.components.getSourceComponents(),
                    defaultDirectory: options.output,
                }
                : {
                    type: 'directory',
                    outputDirectory: options.output,
                };
            const convertResult = yield converter.convert(retrievedComponents, 'source', outputConfig);
            return convertResult.converted;
        });
    }
    metadataDeployID(zipBuffer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options || !options.apiOptions) {
                options = {
                    apiOptions: exports.DEFAULT_API_OPTIONS,
                };
            }
            else {
                for (const [property, value] of Object.entries(exports.DEFAULT_API_OPTIONS)) {
                    if (!(property in options.apiOptions)) {
                        //@ts-ignore ignore while dynamically building the defaults
                        options.apiOptions[property] = value;
                    }
                }
            }
            const result = yield this.connection.metadata.deploy(zipBuffer, options.apiOptions);
            return result.id;
        });
    }
    metadataDeployStatusPoll(deployID, options, interval = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            const wait = (interval) => {
                return new Promise((resolve) => {
                    setTimeout(resolve, interval);
                });
            };
            const timeout = !options || !options.wait ? 10000 : options.wait;
            const endTime = Date.now() + timeout;
            let triedOnce = false;
            do {
                if (triedOnce) {
                    yield wait(interval);
                }
                try {
                    // Recasting to use the library's DeployResult type
                    result = (yield this.connection.metadata.checkDeployStatus(deployID, true));
                }
                catch (e) {
                    throw new errors_1.DeployError('md_request_fail', e);
                }
                switch (result.status) {
                    case types_1.DeployStatus.Succeeded:
                    case types_1.DeployStatus.Failed:
                    case types_1.DeployStatus.Canceled:
                        return result;
                }
                triedOnce = true;
            } while (Date.now() < endTime);
            return result;
        });
    }
    buildSourceDeployResult(componentDeploymentMap, result) {
        const deployResult = {
            id: result.id,
            status: result.status,
            success: result.success,
        };
        const messages = this.getDeployMessages(result);
        const diagnosticUtil = new diagnosticUtil_1.DiagnosticUtil('metadata');
        if (messages.length > 0) {
            deployResult.components = [];
            for (let message of messages) {
                message = this.sanitizeDeployMessage(message);
                const componentKey = `${message.componentType}:${message.fullName}`;
                const componentDeployment = componentDeploymentMap.get(componentKey);
                if (componentDeployment) {
                    if (message.created === 'true') {
                        componentDeployment.status = types_1.ComponentStatus.Created;
                    }
                    else if (message.changed === 'true') {
                        componentDeployment.status = types_1.ComponentStatus.Changed;
                    }
                    else if (message.deleted === 'true') {
                        componentDeployment.status = types_1.ComponentStatus.Deleted;
                    }
                    else if (message.success === 'false') {
                        componentDeployment.status = types_1.ComponentStatus.Failed;
                    }
                    if (message.problem) {
                        diagnosticUtil.setDeployDiagnostic(componentDeployment, message);
                    }
                }
            }
            deployResult.components = Array.from(componentDeploymentMap.values());
        }
        return deployResult;
    }
    getDeployMessages(result) {
        const messages = [];
        if (result.details) {
            const { componentSuccesses, componentFailures } = result.details;
            if (componentSuccesses) {
                if (Array.isArray(componentSuccesses)) {
                    messages.push(...componentSuccesses);
                }
                else {
                    messages.push(componentSuccesses);
                }
            }
            if (componentFailures) {
                if (Array.isArray(componentFailures)) {
                    messages.push(...componentFailures);
                }
                else {
                    messages.push(componentFailures);
                }
            }
        }
        return messages;
    }
    /**
     * Fix any issues with the deploy message returned by the api.
     * TODO: remove as fixes are made in the api.
     */
    sanitizeDeployMessage(message) {
        // lwc doesn't properly use the fullname property in the api.
        message.fullName = message.fullName.replace(/markup:\/\/c:/, '');
        return message;
    }
}
exports.MetadataApi = MetadataApi;
//# sourceMappingURL=metadataApi.js.map